
------------------------------------------------------------------------------------------------
shivrajkaravinakopp@Shivrajs-MacBook-Air Bloomdev % mkdir Interview-questions/doubts
mkdir: Interview-questions: No such file or directory
shivrajkaravinakopp@Shivrajs-MacBook-Air Bloomdev % mkdir Interview-questions/doubts
mkdir: Interview-questions: No such file or directory
shivrajkaravinakopp@Shivrajs-MacBook-Air Bloomdev % mkdir -p Interview-questions/doubts

We can't use the / the git sees it as different command like ittries creating folder doubts but the Interview-questions folder is not yet created so we can use the command 

mkdir -p Interview-questions/doubts

this command creates a parent directory and sub directory also 

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------
why was react introduced what problem did it resolve?


the react solved a very common problem of the js when even a single component is being changed or updated the whole page reloads in the js but in react the component which is changed only loads 

react creates a virtual copy of the dom and than compares itwith the chages we have done in it with the main do and pushes only the chnsges not the full dom

------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------

what does react dom does than 

the react dom connects the react 





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How does the Hashmap work and why is the threshold 8 


1. What is a HashMap?

A HashMap stores data as keyâ€“value pairs:

Key â†’ hash() â†’ index â†’ bucket â†’ value


It provides:

O(1) average insert

O(1) average search

O(1) average delete

ðŸ”¶ 2. Internal Structure

A HashMap internally contains:

Node<K, V>[] table;   // array of buckets


Each bucket stores either:

Linked List of nodes (Java 7)

Linked List OR Red-Black Tree (Java 8+)

Each node looks like:

Node {
    int hash;
    K key;
    V value;
    Node next;
}

ðŸ”¶ 3. How HashMap Works Step-by-Step
Step 1 â€” Compute hash

Java computes hash using:

hash = key.hashCode()


Then it mixes it using:

(hash ^ (hash >>> 16))


(Improves distribution)

Step 2 â€” Find bucket index
index = hash & (capacity - 1)


Example:

Capacity = 16

Computed hash = 01101100

Index = last 4 bits â†’ 1100 â†’ bucket 12

Step 3 â€” Insert / Search in that bucket

If bucket empty â†’ directly insert

If bucket has nodes â†’ compare keys

If collision â†’ insert in list or tree

ðŸ”¶ 4. What Are Collisions?

Collision = when two different keys go to the same bucket index.

Java handles collisions using:

âœ” Before Java 8 â†’ Linked List
Node â†’ Node â†’ Node â†’ ...

âœ” After Java 8 â†’ Linked List + Tree (Red-Black Tree)
If bucket size â‰¥ 8 â†’ convert to Tree
If bucket size â‰¤ 6 â†’ convert back to List

ðŸ”¶ 5. Java 7 vs Java 8 â€” Big Change
Feature	Java 7	Java 8
Collision handling	Only Linked List	Linked List + Red-Black Tree
Worst-case lookup	âŒ O(n)	âœ” O(log n)
Hash mixing	Weak	Better hashing
Rehash process	Can cause loops	Safe + improved
ðŸ”¶ 6. Why Java Added Red-Black Trees (Java 8)?

Because earlier:

If many collisions happen

Linked List becomes long

Searching becomes O(n)

Worst-case attacks possible

Now:

Tree height = log n

Worst-case is O(log n), not O(n)

ðŸ”¶ 7. Why Treeify Threshold = 8? (WHY EXACTLY 8)

This is the most common interview question.

âœ” Reason 1 â€” Probability
Chance of 8 elements landing in the same bucket is extremely rare â†’ about 1 in 60 million.
So if it happens â†’ hash function is weak â†’ use tree.

âœ” Reason 2 â€” Performance Benchmark
For bucket size 1â€“7 â†’ LinkedList is faster
For 8+ â†’ Red-Black Tree becomes faster

âœ” Reason 3 â€” Memory Optimization
Tree nodes are heavy â†’ donâ€™t create them early.

âœ” Reason 4 â€” Tree height
With 8 nodes, tree height is about 3 â†’ good performance.

âœ” Reason 5 â€” Avoid frequent switching
Java also untreeifies when size drops to 6
â†’ prevents flip-flop at 7.

ðŸ”¶ 8. Operations Time Complexity
Operation	Average	Worst Case
Insert	O(1)	O(log n)
Search	O(1)	O(log n)
Delete	O(1)	O(log n)

Worst case happens only if bucket becomes a tree.

ðŸ”¶ 9. Rehashing (When Table Grows)

When size exceeds:

loadFactor * capacity
(default loadFactor = 0.75)


â†’ HashMap doubles capacity
â†’ reassigns elements to new buckets
â†’ still O(1) on average

ðŸ”¶ 10. What is a Bucket?

A bucket is simply an array index.

Each bucket can contain:

Empty
â†“
Single Node
â†“
LinkedList
â†“
Red-Black Tree

ðŸ”¶ 11. Complete HashMap Flow in One Diagram
            hashCode()
Key ----------------------> hash
                               |
                               v
                        hash mixing 
                               |
                               v
                   index = hash & (n-1)
                               |
                               v
            +---------------------------------+
Bucket[i] â†’ |  Node -> Node -> Node -> ...    |  (LL)
            |      OR Red-Black Tree          |
            +---------------------------------+

ðŸ”¶ 12. Why Average O(1)?

Because:

Hashing is constant time

Bucket has only a few elements

Probability of collisions is small

Even in collisions, tree gives O(log n).

ðŸ”¶ 13. Why HashMap Is Faster Than TreeMap?

HashMap â†’ O(1) average
TreeMap â†’ O(log n) always

But HashMap loses ordering â€” TreeMap maintains sorted keys.

ðŸŽ‰ DONE â€” Complete HashMap Notes (Everything Covered)

This chart includes:

âœ” How HashMap works
âœ” Buckets, hashing, collisions
âœ” Java 7 vs Java 8
âœ” LinkedList vs Red-Black Tree
âœ” Why threshold is 8
âœ” Why untreeify at 6
âœ” Rehashing
âœ” Time complexities
âœ” Internal structure visuals 

Bucket 8:

                     (Root: Key M)
                    /             \
           (Key D)                   (Key T)
           /    \                     /    \
     (A)        (F)             (R)        (Z)



Index:       0        1        2        3        4        5        6        7        8        9 ...
-----------------------------------------------------------------------------------------------------
Bucket:     âˆ…        âˆ…        âˆ…       [LL]      âˆ…       [LL]      âˆ…        âˆ…       [Tree]    âˆ…
-----------------------------------------------------------------------------------------------------

[LL] at index 3  (Linked List Collision Chain)
     Node1 (hash=120, key="A", value=10)
         |
         v
     Node2 (hash=120, key="B", value=20)
         |
         v
     Node3 (hash=120, key="C", value=30)


[LL] at index 5  (Another Linked List)
     Node(hash, key="X", value=100)
         |
         v
     Node(hash, key="Y", value=200)


[Tree] at index 8 (Red-Black Tree)
                       (M)
                      /   \
                   (D)     (T)
                  /  \     /  \
                (A) (F)  (R)  (Z)
=====see till 7 element it's just tree after 7th element its tree 






==============================================================================================
| Case             | Bubble Sort               | Selection Sort |
| ---------------- | ------------------------- | -------------- |
| **Best case**    | **O(n)** (with swap flag) | **O(nÂ²)**      |
| **Average case** | O(nÂ²)                     | O(nÂ²)          |
| **Worst case**   | O(nÂ²)                     | O(nÂ²)          |

